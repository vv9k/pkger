<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>pkger</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="installation.html"><strong aria-hidden="true">1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="configuration.html"><strong aria-hidden="true">2.</strong> Configuration</a></li><li class="chapter-item expanded "><a href="recipes.html"><strong aria-hidden="true">3.</strong> Recipes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="metadata.html"><strong aria-hidden="true">3.1.</strong> Metadata</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="rpm.html"><strong aria-hidden="true">3.1.1.</strong> RPM</a></li><li class="chapter-item expanded "><a href="deb.html"><strong aria-hidden="true">3.1.2.</strong> DEB</a></li><li class="chapter-item expanded "><a href="pkg.html"><strong aria-hidden="true">3.1.3.</strong> PKG</a></li><li class="chapter-item expanded "><a href="apk.html"><strong aria-hidden="true">3.1.4.</strong> APK</a></li></ol></li><li class="chapter-item expanded "><a href="scripts.html"><strong aria-hidden="true">3.2.</strong> Scripts</a></li><li class="chapter-item expanded "><a href="env.html"><strong aria-hidden="true">3.3.</strong> Env</a></li></ol></li><li class="chapter-item expanded "><a href="images.html"><strong aria-hidden="true">4.</strong> Images</a></li><li class="chapter-item expanded "><a href="usage.html"><strong aria-hidden="true">5.</strong> Build a package</a></li><li class="chapter-item expanded "><a href="signing.html"><strong aria-hidden="true">6.</strong> Signing packages</a></li><li class="chapter-item expanded "><a href="output.html"><strong aria-hidden="true">7.</strong> Formatting output</a></li><li class="chapter-item expanded "><a href="new.html"><strong aria-hidden="true">8.</strong> Create new recipes and images</a></li><li class="chapter-item expanded "><a href="edit.html"><strong aria-hidden="true">9.</strong> Edit recipes, images and config</a></li><li class="chapter-item expanded "><a href="completions.html"><strong aria-hidden="true">10.</strong> Shell completions</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">pkger</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<p>If you're using Arch Linux you can get <strong>pkger</strong> from <em>AUR</em> repositories with your favourite package manager like so:</p>
<ul>
<li><code>paru pkger-rs</code></li>
</ul>
<p>On other Linux distributions or MacOS download one of the latest prebuild static binaries from
<a href="https://github.com/vv9k/pkger/releases">here</a>. If your desired target is not on the list you'll have to build
<strong>pkger</strong> from source by cloning the repository from <code>https://github.com/vv9k/pkger</code> and building it with:</p>
<ul>
<li><code>cargo build --release</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="configuration"><a class="header" href="#configuration">Configuration</a></h1>
<p>By default <strong>pkger</strong> will look for the config file named <code>.pkger.yml</code> in the config directory appropriate for the OS 
that <strong>pkger</strong> is run on. If there is no global configuration, current directory will be scanned for the same file. 
To specify the location of the config file use <code>--config</code> or <code>-c</code> parameter.</p>
<p>The configuration file has a following structure:</p>
<pre><code class="language-yaml"># required
recipes_dir: &quot;&quot;
output_dir: &quot;&quot;

# optional
log_dir: &quot;&quot;
images_dir: &quot;&quot;
runtime_uri: &quot;unix:///var/run/docker.sock&quot;

# Decides wether `runtime_uri` should be treated as Podman runtime. If false (default) Docker will be used
podman: false

ssh:
  # this will make the ssh auth socket available to the container so that it can use private keys from the host.
  forward_agent: true

  # This will allow tools that use SSH to connect to hosts that are not present in the `known_hosts` file
  disable_key_verification: true


# override default images used by pkger
custom_simple_images:
  deb: ubuntu:latest
  rpm: centos:latest

# To define custom images add the following
images:
  - name: rocky
    target: rpm
  - name: debian
    target: deb
# if pkger fails to find out the operating system you can specify it by os parameter
  - name: arch
    target: pkg
    os: Arch Linux
</code></pre>
<p>The required fields when running a build are <code>recipes_dir</code> and <code>output_dir</code>. First tells <strong>pkger</strong> where to look for
<a href="./recipes.html">recipes</a> to build, the second is the directory where the final packages will end up.</p>
<p>When using <a href="./images.html">custom images</a> their location can be specified with <code>images_dir</code>.</p>
<p>If Docker daemon that <strong>pkger</strong> should connect does not run on a default unix socket override the uri with <code>runtime_uri</code>
parameter.</p>
<p>To use Podman as the container runtime, set <code>podman: true</code>.</p>
<p>If an option is available as both configuration parameter and cli argument <strong>pkger</strong> will favour the arguments passed
during startup.</p>
<h2 id="generate-configuration-file-and-directories"><a class="header" href="#generate-configuration-file-and-directories">Generate configuration file and directories</a></h2>
<p>To quickly start of with <strong>pkger</strong> use the <code>pkger init</code> subcommand that will create necessary directories and the
configuration file. Default locations can be overridden by command line parameters.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="recipes"><a class="header" href="#recipes">Recipes</a></h1>
<p>Each recipe is a directory containing at least a <code>recipe.yml</code> or <code>recipe.yaml</code> file located at <code>recipes_dir</code> specified
in the <a href="./configuration.html">configuration</a>.</p>
<p>The recipe is divided into 2 required (<em>metadata</em>, <em>build</em>) and 3 optional (<em>config</em>, <em>install</em>, <em>env</em>) parts.
To read more on each topic select a subsection in the menu.</p>
<p>Here's an example working recipe for <strong>pkger</strong>:</p>
<pre><code class="language-yaml">metadata:
  name: pkger
  description: pkger
  arch: x86_64
  license: MIT
  version: 0.1.0
  maintainer: &quot;Wojciech Kępka &lt;wojciech@wkepka.dev&gt;&quot;
  url: &quot;https://github.com/vv9k/pkger&quot;
  git: &quot;https://github.com/vv9k/pkger.git&quot;
  provides: [ pkger ]
  depends:
    pkger-deb: [ libssl-dev ]
    pkger-rpm: [ openssl-devel ]
  build_depends:
    all: [ gcc, pkg-config ]
    pkger-deb: [ curl libssl-dev ]
    pkger-rpm: [ cargo ]
    pkger-pkg: [ cargo ]
env:
  RUSTUP_URL: https://sh.rustup.rs
configure:
  steps:
    - cmd: curl -o /tmp/install_rust.sh $RUSTUP_URL
      deb: true
    - cmd: sh /tmp/install_rust.sh -y --default-toolchain stable
      deb: true
build:
  steps:
    - cmd: cargo build --color=never
      rpm: true
      pkg: true
    - cmd: $HOME/.cargo/bin/cargo build --color=never
      deb: true
install:
  steps:
    - cmd: dir -p usr/bin
    - cmd: install -m755 $PKGER_BLD_DIR/target/debug/pkger usr/bin/

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="metadata-required"><a class="header" href="#metadata-required">Metadata (Required)</a></h1>
<p>Contains all fields that describe the package being built.</p>
<h2 id="required-fields"><a class="header" href="#required-fields">required fields</a></h2>
<pre><code class="language-yaml">metadata:
  name: pkger
  description: pkger
  license: MIT
  version: 0.1.0
</code></pre>
<h2 id="optional-fields"><a class="header" href="#optional-fields">optional fields</a></h2>
<p>To specify which images a recipe should use add images parameter with a list of image targets. This field is ignored
when building with <code>--simple</code> flag.</p>
<pre><code class="language-yaml">  images: [ rocky, debian ]
</code></pre>
<p>You can also specify that all images apply to this recipe with:</p>
<pre><code class="language-yaml">  all_images: true
</code></pre>
<h3 id="sources"><a class="header" href="#sources">sources</a></h3>
<p>This fields are responsible for fetching the files used for the build. When both <code>git</code> and <code>source</code> are specified
<strong>pkger</strong> will fetch both to the build directory.</p>
<p>If <code>source</code> starts with a prefix like <code>http</code> or <code>https</code> the file that if points to will be downloaded. If the file is an
archive like <code>.tar.gz</code> or <code>.tar.xz</code> or <code>.zip</code> it will be directly extracted to
<a href="./env.html#pkger-variables"><code>$PKGER_BLD_DIR</code></a>, otherwise the file will be copied to the directory untouched.</p>
<pre><code class="language-yaml">  source: &quot;&quot; # remote source or file system location

  git: https://github.com/vv9k/pkger.git # will default to branch = &quot;master&quot;

  # or specify a branch like this:
  git:
    url: https://github.com/vv9k/pkger.git
    branch: dev
</code></pre>
<p><a href="./env.html">Environment variables</a> are available for this fields so this is possible:</p>
<pre><code class="language-yaml">  source: &quot;https://github.com/vv9k/${RECIPE}/${RECIPE_VERSION}&quot;
</code></pre>
<h3 id="common"><a class="header" href="#common">common</a></h3>
<p>Optional fields shared across all targets.</p>
<pre><code class="language-yaml">  release: &quot;1&quot; # defaults to &quot;0&quot;

  epoch: &quot;42&quot;

  maintainer: &quot;Wojciech Kępka &lt;wojciech@wkepka.dev&gt;&quot;

# The website of the package being built
  url: https://github.com/vv9k/pkger

  arch: x86_64 # defaults to `noarch` on RPM and `all` on DEB, `x86_64` automatically converted to `amd64` on DEB...

  skip_default_deps: true # skip installing default dependencies, it might break the builds

  exclude: [&quot;share&quot;, &quot;info&quot;] # directories to exclude from final package

  group: &quot;&quot; # acts as Group in RPM or Section in DEB build
</code></pre>
<h3 id="dependencies"><a class="header" href="#dependencies">dependencies</a></h3>
<p>Common fields that specify dependencies, conflicts and provides will be added to the spec of the final package. </p>
<p>This fields can be specified as arrays:</p>
<pre><code class="language-yaml">  depends: []
  conflicts: []
  provides: []
</code></pre>
<p>Or specified per image as a map below.</p>
<p><strong>pkger</strong> will install all dependencies listed in <code>build_depends</code>, choosing an appropriate package manager for each
supported distribution. Default dependencies like <code>gzip</code> or <code>git</code> might be installed depending on the target job type.</p>
<pre><code class="language-yaml">  build_depends:
    # common dependencies shared across all images
    all: [&quot;gcc&quot;, &quot;pkg-config&quot;, &quot;git&quot;]

    # dependencies for custom images
    rocky: [&quot;cargo&quot;, &quot;openssl-devel&quot;]
    debian: [&quot;curl&quot;, &quot;libssl-dev&quot;]
</code></pre>
<p>To specify same dependencies for multiple images join the images by <code>+</code> sign like this:</p>
<pre><code class="language-yaml">    rocky+fedora34: [ cargo, openssl-devel ]
    ubuntu20+debian: [ libssl-dev ]
    # you can later specify dependencies just for this images
    debian: [ curl ]
</code></pre>
<p>if running a simple build and there is a need to specify dependencies for the target add dependencies for one of this
images:</p>
<pre><code class="language-yaml">    pkger-rpm+pkger-apk+pkger-pkg: [&quot;cargo&quot;]
    pkger-deb: [&quot;curl&quot;]
    pkger-gzip: []
</code></pre>
<p>A custom image, for example <code>rocky</code>, will also use dependecies defined for <code>pkger-rpm</code>. The same will apply for all rpm based images (or images that have their target specified to RPM in the <a href="./configuration.html">configuration</a>)</p>
<h3 id="patches"><a class="header" href="#patches">Patches</a></h3>
<p>To apply patches to the fetched source code specify them just like dependencies. Patches can be specified as just file
name in which case <strong>pkger</strong> will look for the patch in the recipe directory, if the path is absolute it will be read
directly from the file system and finally if the patch starts with an <code>http</code> or <code>https</code> prefix the patch will be fetched
from remote source.</p>
<pre><code class="language-yaml">  patches:
    - some-local.patch
    - /some/absolute/path/to.patch
    - https://someremotesource.com/other.patch
    - patch: with-strip-level.patch
      images: [ debian ] # specify the images that this patch should be aplied on
      strip: 2 # this specifies the number of directories to strip before applying the patch (known as -pN or --stripN option in UNIX patch tool
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rpm-fields"><a class="header" href="#rpm-fields">RPM fields</a></h1>
<p>Optional fields that will be used when building RPM target.</p>
<pre><code class="language-yaml">  rpm:
    vendor: &quot;&quot;
    icon: &quot;&quot;
    summary: &quot;shorter description&quot; # if not provided defaults to value of `description`
    config_noreplace: &quot;%{_sysconfdir}/%{name}/%{name}.conf&quot;

    pre_script: &quot;&quot;
    post_script: &quot;&quot;
    preun_script: &quot;&quot;
    postun_script: &quot;&quot;
    
    # Disable automatic dependency processing. Setting this to true has no effect.
    auto_req_prov: false

    # acts the same as other dependencies - can be passed as array
    #obsoletes: [&quot;foo&quot;]
    # or as a map
    obsoletes:
      rocky: [&quot;foo&quot;]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="deb-fields"><a class="header" href="#deb-fields">DEB fields</a></h1>
<p>Optional fields that may be used when building a DEB package.</p>
<pre><code class="language-yaml">  deb:
    priority: &quot;&quot;
    built_using: &quot;&quot;
    essential: true
    
    # specify the content of post install script
    postinst: &quot;&quot;

    # same as all other dependencies but deb specific
    pre_depends: []
    recommends: []
    suggests: []
    breaks: []
    replaces: []
    enhances: []
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pkg-fields"><a class="header" href="#pkg-fields">PKG fields</a></h1>
<p>Optional fields that will be used when building a PKG package.</p>
<pre><code class="language-yaml">  pkg:
    # location of the script in `$PKGER_OUT_DIR` that contains pre/post install/upgrade/remove functions
    # to be included in the final pkg
    install: &quot;.install&quot;
    
    # A list of files to be backed up when package will be removed or upgraded
    backup: [&quot;/etc/pkger.conf&quot;]
    
    # A list of packages that this package replaces
    replaces: []
    
    # This are dependencies that this package needs to offer full functionality.
    optdepends:
      # Each dependency should contain a short description in this format:
      - &quot;libpng: PNG images support&quot;
      - &quot;alsa-lib: sound support&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="apk-fields"><a class="header" href="#apk-fields">APK fields</a></h1>
<p>Optional fields that will be used when building a APK package.</p>
<pre><code class="language-yaml">  apk:
    install: &quot;$pkgname.pre-install $pkgname.post-install&quot;
    
    # A list of packages that this package replaces
    replaces: []

    # A list of dependencies for the check phase
    checkdepends: []

    # If not provided a new generated key will be used to
    # sign the package
    private_key: &quot;/location/of/apk_signing_key&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scripts"><a class="header" href="#scripts">Scripts</a></h1>
<p><strong>pkger</strong> has 3 defined build phases - <em>configure</em>, <em>build</em> and <em>install</em> of which only <em>build</em> is required to create a
package.</p>
<p>Each phase has field called <code>steps</code> that takes an array of steps to execute during a given phase. A step can be a simple
string that will be executed in the default shell like <code>&quot;echo 123&quot;</code> or an entry that specifies on what targets it should
be executed like:</p>
<pre><code class="language-yaml">    - cmd: &gt;-
        echo only on deb targets
      deb: true
</code></pre>
<p>To set a working directory during the script phase set the <code>working_dir</code> parameter like so:</p>
<pre><code class="language-yaml">  working_dir: /tmp
</code></pre>
<p><a href="./env.html">Environment variables</a> are available for this field so this is possible:</p>
<pre><code class="language-yaml">  working_dir: ${PKGER_BLD_DIR}/${RECIPE}-${RECIPE_VERSION}-${SOME_USER_DEFINED_VAR}
</code></pre>
<p>To use a different shell to execute each command set the <code>shell</code> parameter:</p>
<pre><code class="language-yaml">  shell: &quot;/bin/bash&quot; # optionally change default `/bin/sh`
</code></pre>
<h2 id="configure-optional"><a class="header" href="#configure-optional">configure (Optional)</a></h2>
<p>Optional configuration steps. If provided the steps will be executed before the build phase.
The working directory will be set to <a href="./env.html#pkger-variables"><code>$PKGER_BLD_DIR</code></a></p>
<pre><code class="language-yaml">configure:
  shell: &quot;/bin/bash&quot;
  steps:
    - cmd: &gt;-
        curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
</code></pre>
<h2 id="build-required"><a class="header" href="#build-required">build (Required)</a></h2>
<p>This is the phase where the package should be assembled/compiled/linked and so on. All steps executed during the build
will have the working directory seto to <a href="./env.html#pkger-variables"><code>$PKGER_BLD_DIR</code></a>. This directory will contain either
extracted sources if <code>source</code> is specified in <a href="./metadata.html#optional-fields">metadata</a> or a git repository if <code>git</code>
was specified.</p>
<pre><code class="language-yaml">build:
  steps:
    - cmd: $HOME/.cargo/bin/cargo build --release .
    - images = [&quot;debian&quot;]
      cmd: echo 'hello from Debian' # will only be executed on image `debian`
    - cmd: echo 'will only run on images with target == `rpm`'
      rpm: true
    # same applies to other targets
]
</code></pre>
<h2 id="install-optional"><a class="header" href="#install-optional">install (Optional)</a></h2>
<p>Optional steps that (if provided) will be executed after the build phase. Working directory of each step will be set to
<a href="./env.html#pkger-variables"><code>$PKGER_OUT_DIR</code></a> so you can use relative paths with commands like install. Each file that
ends up in <a href="./env.html#pkger-variables"><code>$PKGER_OUT_DIR</code></a> will be available in the final package unless explicitly
excluded by <code>exclude</code> field in <a href="./metadata.html#optional-fields">metadata</a>. So in the example below, the file that is
installed will be available as <code>/usr/bin/pkger</code> with permissions preserved.</p>
<pre><code class="language-yaml">install:
  steps:
    - cmd: &gt;-
        install -m755 $PKGER_BLD_DIR/target/release/pkger usr/bin/pkger
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="env-optional"><a class="header" href="#env-optional">env (Optional)</a></h1>
<p>Optional environment variables that should be available during the <a href="./scripts.html">scripts</a> phase and
in some metadata fields.</p>
<pre><code class="language-yaml">env:
  HTTPS_PROXY: http://proxy.domain.com:1234
  RUST_LOG: trace
</code></pre>
<h1 id="pkger-variables"><a class="header" href="#pkger-variables"><strong>pkger</strong> variables</a></h1>
<p>Some variables will be available to use during the build like:</p>
<ul>
<li><code>$PKGER_OS</code> the distribution of current container</li>
<li><code>$PKGER_OS_VERSION</code> version of the distribution if applies</li>
<li><code>$PKGER_BLD_DIR</code> the build directory with fetched source or git repo in the container</li>
<li><code>$PKGER_OUT_DIR</code> the final directory from which <strong>pkger</strong> will copy files to target package</li>
<li><code>$RECIPE</code> the name of the recipe that is built</li>
<li><code>$RECIPE_VERSION</code> the version of the recipe</li>
<li><code>$RECIPE_RELEASE</code> the release of the recipe</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="images"><a class="header" href="#images">Images</a></h1>
<p>Images are an optional feature of <strong>pkger</strong>.By default <strong>pkger</strong> will create necessary images to build simple targets,
they are completely distinct from user defined ones. User images offer higher customisation when it comes to preparing
the build environment.</p>
<p>In the images directory specified by the <a href="./configuration.html">configuration</a> <strong>pkger</strong> will treat each subdirectory
containing a <code>Dockerfile</code> as an image. The name of the directory will become the name of the image.</p>
<p>So example structure like this:</p>
<pre><code>images
├── arch
│  └── Dockerfile
├── rocky
│  └── Dockerfile
└── debian
   └── Dockerfile
</code></pre>
<p><strong>pkger</strong> will detect 3 images - <em>arch</em>, <em>rocky</em> and <em>debian</em>.</p>
<p>Images with dependencies installed will be cached for each recipe-target combo to reduce the number of times the
dependencies have to be pulled from remote sources. This saves a lot of space, time and bandwith.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="build-a-package"><a class="header" href="#build-a-package">Build a package</a></h1>
<p>Currently available targets are: <strong>rpm</strong>, <strong>deb</strong>, <strong>pkg</strong>, <strong>apk</strong>, <strong>gzip</strong>.</p>
<h3 id="simple-build"><a class="header" href="#simple-build">Simple build</a></h3>
<p>To build a simple package using <strong>pkger</strong> use:</p>
<pre><code class="language-shell">pkger build --simple [TARGETS] -- [RECIPES]
</code></pre>
<p>When using a simple build following linux distributions will be used for build images:</p>
<ul>
<li>rpm: <code>rockylinux/rockylinux:latest</code></li>
<li>deb: <code>debian:latest</code></li>
<li>pkg: <code>archlinux</code></li>
<li>apk: <code>alpine:latest</code></li>
<li>gzip: <code>debian:latest</code></li>
</ul>
<p>To override the default images set <code>custom_simple_images</code> like this:</p>
<pre><code class="language-yaml">custom_simple_images:
  deb: ubuntu:18
  rpm: fedora:latest
</code></pre>
<h3 id="custom-images-build"><a class="header" href="#custom-images-build">Custom images build</a></h3>
<p>To use <a href="./images.html">custom images</a> drop the <code>--simple</code> parameter and just use:</p>
<pre><code class="language-shell">pkger build [RECIPES]
</code></pre>
<p>For this to have any effect the recipes have to have image targets defined (more on that <a href="./metadata.html#optional-fields">here</a>)</p>
<h3 id="examples"><a class="header" href="#examples">Examples</a></h3>
<h4 id="build-a-recipe-for-all-supported-images"><a class="header" href="#build-a-recipe-for-all-supported-images">Build a recipe for all supported images:</a></h4>
<pre><code class="language-shell">pkger build recipe
</code></pre>
<h4 id="build-all-recipes-for-all-supported-images"><a class="header" href="#build-all-recipes-for-all-supported-images">Build all recipes for all supported images</a></h4>
<pre><code class="language-shell">pkger build --all
</code></pre>
<h4 id="build-multiple-recipes-on-specified-custom-images"><a class="header" href="#build-multiple-recipes-on-specified-custom-images">Build multiple recipes on specified custom images:</a></h4>
<pre><code class="language-shell">pkger build -i custom-image1 custom-image2 -- recipe1 recipe2
</code></pre>
<h4 id="build-simple-rpm-deb-pkg-packages"><a class="header" href="#build-simple-rpm-deb-pkg-packages">Build simple RPM, DEB, PKG... packages:</a></h4>
<pre><code class="language-shell">pkger build -s rpm -s deb -s pkg -s gzip -- recipe1
</code></pre>
<h4 id="build-only-rpm-package"><a class="header" href="#build-only-rpm-package">Build only RPM package:</a></h4>
<pre><code class="language-shell">pkger build -s rpm -- recipe1
</code></pre>
<h3 id="output"><a class="header" href="#output">Output</a></h3>
<p>After successfully building a package <strong>pkger</strong> will put the output artifact to <code>output_dir</code> specified in
<a href="./configuration.html">configuration</a> joined by the image name that was used to build the package.
Each image will have a separate directory with all of its output packages.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="signing"><a class="header" href="#signing">Signing</a></h1>
<p>To sign packages automatically using a GPG key add the following to your <a href="./configuration.html">configuration file</a>:</p>
<pre><code class="language-yaml">gpg_key: /absolute/path/to/the/private/key
gpg_name: Packager Name # must be the same as the `Name` field on the key
</code></pre>
<p>When <strong>pkger</strong> detects the gpg key in the configuration it will prompt for a password to the key on each run.</p>
<p>Currently, only <em>deb</em> and <em>rpm</em> targets support signing.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="formatting-output"><a class="header" href="#formatting-output">Formatting output</a></h1>
<p>By default <strong>pkger</strong> will display basic output as hierhical log with level set to <code>INFO</code>. All log messages will be printed to stdout unless a <code>--log-dir</code> flag (or <code>log_dir</code> is specified in <a href="./configuration.html">configuration</a>) is provided, in that case there will be a single global log file in the logging directory created on each run as well as a separate file for each task.</p>
<p>To debug run with <code>-d</code> or <code>--debug</code> option. To surpress all output except for errors and warnings add <code>-q</code> or <code>--quiet</code>. To enable very verbose output add <code>-t</code> or `--trace option.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generate-recipes"><a class="header" href="#generate-recipes">Generate recipes</a></h1>
<p>To generate a recipe declaratively from CLI use the <code>pkger new recipe</code> subcommand. By default it requires only the name
of the  package and creates a directory with <code>recipe.yml</code> in it.</p>
<h1 id="create-images"><a class="header" href="#create-images">Create images</a></h1>
<p>To create images use <code>pkger new image &lt;name&gt;</code>. This will create a directory with a <code>Dockerfile</code> in the <code>images_dir</code>
specified in the <a href="./configuration.html">configuration</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="edit-recipes-images-and-config"><a class="header" href="#edit-recipes-images-and-config">Edit recipes, images and config</a></h1>
<p><strong>pkger</strong> provides utility subcommand <code>edit</code> that invokes the default editor defined by <code>$EDITOR</code> environment variable.
To make this functionality work, export this variable in your shell's init script like <code>~/.bashrc</code>.</p>
<p>Edit images and recipes by name:</p>
<pre><code># This will open up the Dockerfile in the `rocky` image.
$ pkger edit image rocky 

# This will open up the `recipe.yml` or `recipe.yaml` file in `pkger-simple` recipe directory
$ pkger edit recipe pkger-simple

</code></pre>
<p>To edit the configuration file run:</p>
<pre><code>$ pkger edit config
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="shell-completions"><a class="header" href="#shell-completions">Shell completions</a></h1>
<p><strong>pkger</strong> provides a subcommand to print shell completions. Supported shells are: <em>bash</em>, <em>zsh</em>, <em>fish</em>, <em>powershell</em>, <em>elvish</em>.</p>
<p>To print the completions run:</p>
<pre><code class="language-shell">pkger print-completions bash
</code></pre>
<p>replacing <code>bash</code> with whatever shell you prefer.</p>
<p>To have completions automatically add something along those lines to your <code>.bashrc</code>, <code>.zshrc</code>...:</p>
<pre><code class="language-shell">. &lt;(pkger print-completions bash)
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
